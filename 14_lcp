#include <bits/stdc++.h>
using namespace std;

// ? Задача - https://leetcode.com/problems/longest-common-prefix/
// ? Lvl - Easy

string longestCommonPrefix(vector<string>& strs) {
   for (int i = 0; i < strs[0].length(); i++) {
       for (const string s: strs) {
           if (i == s.length() || s[i] != strs[0][i]) {
               return s.substr(0,i);
           }
       }
   }
   return strs[0];
}

/* * Решение
 * Идея такая: проходится по i-ому символу каждой строки и сравнивать
 * Логически рассуждая, лучше всего брать самую короткую строку, т.к длиннее префикса быть не может
 * Но если не сортировать массив по длине, можно выбрать любую строку в качестве длины(кол-ва символов), я выбрал 1-ую
 * Потом проходимся по всем строкам и если у нас вдруг i окажется больше длины текущей строки(то есть найдена более
 * короткая строка(но не обязательно самая короткая)) или если символ 1-ой строки(можно с ней сравнивать) не совпадает
 * с символом текущей строки, то возвращаем подстроку(с начала строки берем i символов)
 * Если же у нас весь цикл полностью отработает, то это всего лишь означает, что строку, которую мы выбрали в качестве
 * длины, и есть наша самая длинная подстрока(ибо не выполнилось нахождении более короткой строки, при этом каждый
 * символ каждой строки совпадал с символом нашей строки) => вернем 1-ую строку
 *  */

int main() {
    vector<string> strs {"flower","flow","flight"};
    cout << longestCommonPrefix(strs);
    return 0;
}
